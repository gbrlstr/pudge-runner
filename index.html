<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pudge Runner - DOTA 2 Endless Runner</title>
  <meta name="description" content="Um jogo endless runner baseado no Pudge do DOTA 2. Desvie dos obstáculos e alcance a maior pontuação!">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="./assets/style.css" />
</head>
<body>
  <div class="game-container">
    <div class="ui-panel score-panel">
      <div class="stats-display">
        <div class="stat-item">
          <div class="stat-label">SCORE</div>
          <div class="stat-value" id="currentScore">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">BEST</div>
          <div class="stat-value" id="bestScore">0</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">LEVEL</div>
          <div class="stat-value" id="currentLevel">1</div>
        </div>
      </div>
    </div>

    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <div class="ui-panel controls-panel">
      <div class="controls-list">
        <span class="key">SPACE</span>
        <span>Pular</span>
        <span class="key">R</span>
        <span>Reiniciar</span>
        <span class="key">P</span>
        <span>Pausar</span>
        <span class="key">M</span>
        <span>Menu</span>
      </div>
    </div>

    <div class="loading-screen" id="loadingScreen">
      <div class="loading-title">PUDGE RUNNER</div>
      <div class="loading-bar">
        <div class="loading-progress" id="loadingProgress"></div>
      </div>
      <div class="loading-text" id="loadingText">Carregando assets...</div>
    </div>

    <div class="menu-overlay" id="menuOverlay" style="display: none;">
      <div class="menu-title">PUDGE RUNNER</div>
      <div class="menu-subtitle">Desvie dos ganchos e sobreviva o máximo possível!</div>
      <button class="menu-button" id="startButton">INICIAR JOGO</button>
    </div>

    <div class="menu-overlay" id="gameOverOverlay" style="display: none;">
      <div class="menu-title">GAME OVER</div>
      <div class="menu-subtitle" id="finalScore">Pontuação Final: 0</div>
      <button class="menu-button" id="restartButton">JOGAR NOVAMENTE</button>
    </div>

    <div class="menu-overlay" id="pauseOverlay" style="display: none;">
      <div class="menu-title">PAUSADO</div>
      <div class="menu-subtitle">Pressione P para continuar</div>
    </div>
  </div>

  <div class="version-info">
    Pudge Runner v2.0 - Enhanced Edition
  </div>

  <script>
    // ==========================
    // PUDGE RUNNER - Enhanced Edition
    // ==========================

    class PudgeRunner {
      constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.initializeElements();
        this.initializeConfig();
        this.initializeGameState();
        this.initializeAssets();
        this.bindEvents();
        this.startLoadingSequence();
      }

      initializeElements() {
        this.elements = {
          loadingScreen: document.getElementById('loadingScreen'),
          loadingProgress: document.getElementById('loadingProgress'),
          loadingText: document.getElementById('loadingText'),
          menuOverlay: document.getElementById('menuOverlay'),
          gameOverOverlay: document.getElementById('gameOverOverlay'),
          pauseOverlay: document.getElementById('pauseOverlay'),
          startButton: document.getElementById('startButton'),
          restartButton: document.getElementById('restartButton'),
          currentScore: document.getElementById('currentScore'),
          bestScore: document.getElementById('bestScore'),
          currentLevel: document.getElementById('currentLevel'),
          finalScore: document.getElementById('finalScore')
        };
      }

      initializeConfig() {
        this.config = {
          GROUND_Y: this.canvas.height - 50,
          GRAVITY: 0.8,
          JUMP_POWER: -16,
          BASE_SPEED: 5,
          OBSTACLE_SPAWN_RATE: 120,
          PARTICLE_COUNT: 100,
          LEVELS: [
            { speed: 5, spawnRate: 120, name: "Iniciante" },
            { speed: 6, spawnRate: 110, name: "Fácil" },
            { speed: 7, spawnRate: 100, name: "Normal" },
            { speed: 8, spawnRate: 90, name: "Difícil" },
            { speed: 9, spawnRate: 80, name: "Expert" },
            { speed: 10, spawnRate: 70, name: "Insano" }
          ]
        };

        this.sprites = {
          pudge: null,
          hook: null,
          tree: null
        };

        this.spriteUrls = {
          pudge: 'https://static.wikia.nocookie.net/dota2_gamepedia/images/d/d5/Pudge_icon.png',
          hook: 'https://static.wikia.nocookie.net/dota2_gamepedia/images/f/f4/Meat_Hook_icon.png',
          tree: 'https://static.wikia.nocookie.net/dota2_gamepedia/images/8/89/Iron_Branch_icon.png'
        };
      }

      initializeGameState() {
        this.gameState = {
          started: false,
          paused: false,
          gameOver: false,
          assetsLoaded: false,
          frame: 0,
          score: 0,
          level: 1,
          speed: this.config.BASE_SPEED,
          spawnRate: this.config.OBSTACLE_SPAWN_RATE
        };

        this.pudge = {
          x: 80,
          y: this.config.GROUND_Y - 90,
          width: 90,
          height: 90,
          dy: 0,
          grounded: true,
          animFrame: 0
        };

        this.obstacles = [];
        this.particles = [];
        this.backgroundElements = [];
        
        this.loadBestScore();
        this.initializeBackground();
      }

      initializeAssets() {
        this.soundEnabled = true;
        // Note: Audio would be added here in a full implementation
      }

      initializeBackground() {
        // Create background elements for parallax effect
        for (let i = 0; i < 10; i++) {
          this.backgroundElements.push({
            x: Math.random() * this.canvas.width * 2,
            y: Math.random() * (this.config.GROUND_Y - 100),
            size: Math.random() * 3 + 1,
            speed: Math.random() * 0.5 + 0.1,
            opacity: Math.random() * 0.3 + 0.1
          });
        }
      }

      async startLoadingSequence() {
        this.updateLoadingProgress(0, "Inicializando...");
        
        await this.delay(500);
        this.updateLoadingProgress(25, "Carregando sprites...");
        
        await this.loadAssets();
        this.updateLoadingProgress(75, "Preparando jogo...");
        
        await this.delay(800);
        this.updateLoadingProgress(100, "Concluído!");
        
        await this.delay(500);
        this.showMainMenu();
      }

      updateLoadingProgress(percentage, text) {
        this.elements.loadingProgress.style.width = percentage + '%';
        this.elements.loadingText.textContent = text;
      }

      async loadAssets() {
        const spriteKeys = Object.keys(this.spriteUrls);
        let loaded = 0;

        for (const key of spriteKeys) {
          try {
            const image = await this.loadImage(this.spriteUrls[key]);
            this.sprites[key] = image;
            loaded++;
          } catch (error) {
            console.warn(`Falha ao carregar sprite ${key}:`, error);
            this.sprites[key] = null;
            loaded++;
          }
          
          const progress = 25 + (loaded / spriteKeys.length) * 50;
          this.updateLoadingProgress(progress, `Carregando sprites... ${loaded}/${spriteKeys.length}`);
          await this.delay(200);
        }

        this.gameState.assetsLoaded = true;
      }

      loadImage(url) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error(`Failed to load: ${url}`));
          img.src = url;
        });
      }

      delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      showMainMenu() {
        this.elements.loadingScreen.style.display = 'none';
        this.elements.menuOverlay.style.display = 'flex';
        this.updateUI();
      }

      bindEvents() {
        this.elements.startButton.addEventListener('click', () => this.startGame());
        this.elements.restartButton.addEventListener('click', () => this.restartGame());

        document.addEventListener('keydown', (e) => this.handleKeyDown(e));
        document.addEventListener('keyup', (e) => this.handleKeyUp(e));

        // Touch support for mobile
        this.canvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.jump();
        });

        // Visibility API for auto-pause
        document.addEventListener('visibilitychange', () => {
          if (document.hidden && this.gameState.started && !this.gameState.gameOver) {
            this.pauseGame();
          }
        });
      }

      handleKeyDown(e) {
        e.preventDefault();
        
        switch(e.code) {
          case 'Space':
            if (!this.gameState.started) {
              this.startGame();
            } else if (!this.gameState.gameOver && !this.gameState.paused) {
              this.jump();
            }
            break;
          case 'KeyR':
            if (this.gameState.gameOver) {
              this.restartGame();
            }
            break;
          case 'KeyP':
            if (this.gameState.started && !this.gameState.gameOver) {
              this.togglePause();
            }
            break;
          case 'KeyM':
            if (!this.gameState.started) {
              this.showMainMenu();
            }
            break;
        }
      }

      handleKeyUp(e) {
        // Handle key releases if needed
      }

      startGame() {
        this.gameState.started = true;
        this.gameState.paused = false;
        this.gameState.gameOver = false;
        this.hideAllOverlays();
        this.gameLoop();
      }

      restartGame() {
        this.initializeGameState();
        this.loadBestScore();
        this.startGame();
      }

      pauseGame() {
        this.gameState.paused = true;
        this.elements.pauseOverlay.style.display = 'flex';
      }

      togglePause() {
        if (this.gameState.paused) {
          this.gameState.paused = false;
          this.elements.pauseOverlay.style.display = 'none';
        } else {
          this.pauseGame();
        }
      }

      hideAllOverlays() {
        this.elements.menuOverlay.style.display = 'none';
        this.elements.gameOverOverlay.style.display = 'none';
        this.elements.pauseOverlay.style.display = 'none';
      }

      jump() {
        if (this.pudge.grounded) {
          this.pudge.dy = this.config.JUMP_POWER;
          this.pudge.grounded = false;
          this.createJumpParticles();
        }
      }

      createJumpParticles() {
        for (let i = 0; i < 8; i++) {
          this.particles.push({
            x: this.pudge.x + this.pudge.width / 2,
            y: this.pudge.y + this.pudge.height,
            dx: (Math.random() - 0.5) * 4,
            dy: Math.random() * -3 - 1,
            life: 30,
            maxLife: 30,
            color: `hsl(${Math.random() * 60 + 200}, 70%, 60%)`
          });
        }
      }

      createCollisionParticles(x, y) {
        for (let i = 0; i < 15; i++) {
          this.particles.push({
            x: x,
            y: y,
            dx: (Math.random() - 0.5) * 8,
            dy: (Math.random() - 0.5) * 8,
            life: 40,
            maxLife: 40,
            color: `hsl(${Math.random() * 60}, 100%, 50%)`
          });
        }
      }

      updateGame() {
        if (this.gameState.paused || this.gameState.gameOver) return;

        this.gameState.frame++;
        this.updatePudge();
        this.updateObstacles();
        this.updateParticles();
        this.updateBackground();
        this.updateDifficulty();
        this.updateUI();
      }

      updatePudge() {
        // Apply gravity
        this.pudge.dy += this.config.GRAVITY;
        this.pudge.y += this.pudge.dy;

        // Ground collision
        if (this.pudge.y + this.pudge.height >= this.config.GROUND_Y) {
          this.pudge.y = this.config.GROUND_Y - this.pudge.height;
          this.pudge.dy = 0;
          this.pudge.grounded = true;
        }

        // Animation
        this.pudge.animFrame += 0.2;
      }

      updateObstacles() {
        // Spawn obstacles
        if (this.gameState.frame % this.gameState.spawnRate === 0) {
          this.spawnObstacle();
        }

        // Update existing obstacles
        for (let i = this.obstacles.length - 1; i >= 0; i--) {
          const obstacle = this.obstacles[i];
          obstacle.x -= this.gameState.speed;

          // Check collision
          if (this.isColliding(this.pudge, obstacle)) {
            this.createCollisionParticles(
              obstacle.x + obstacle.width / 2, 
              obstacle.y + obstacle.height / 2
            );
            this.gameOver();
            return;
          }

          // Remove off-screen obstacles and award points
          if (obstacle.x + obstacle.width < 0) {
            this.obstacles.splice(i, 1);
            this.gameState.score += 10;
          }
        }
      }

      updateParticles() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
          const particle = this.particles[i];
          particle.x += particle.dx;
          particle.y += particle.dy;
          particle.dy += 0.1; // gravity
          particle.life--;

          if (particle.life <= 0) {
            this.particles.splice(i, 1);
          }
        }
      }

      updateBackground() {
        this.backgroundElements.forEach(element => {
          element.x -= element.speed;
          if (element.x < -10) {
            element.x = this.canvas.width + 10;
          }
        });
      }

      updateDifficulty() {
        const newLevel = Math.floor(this.gameState.score / 100) + 1;
        if (newLevel !== this.gameState.level && newLevel <= this.config.LEVELS.length) {
          this.gameState.level = newLevel;
          const levelConfig = this.config.LEVELS[newLevel - 1];
          this.gameState.speed = levelConfig.speed;
          this.gameState.spawnRate = levelConfig.spawnRate;
        }
      }

      spawnObstacle() {
        const types = ['hook', 'tree'];
        const type = types[Math.floor(Math.random() * types.length)];
        
        const configs = {
          hook: { width: 70, height: 70, color: '#e74c3c' },
          tree: { width: 60, height: 120, color: '#27ae60' }
        };

        const config = configs[type];
        const obstacle = {
          x: this.canvas.width,
          y: this.config.GROUND_Y - config.height,
          width: config.width,
          height: config.height,
          type: type,
          color: config.color,
          animOffset: Math.random() * Math.PI * 2
        };

        this.obstacles.push(obstacle);
      }

      isColliding(rect1, rect2) {
        // Add some padding for more forgiving collision
        const padding = 8;
        return (
          rect1.x + padding < rect2.x + rect2.width - padding &&
          rect1.x + rect1.width - padding > rect2.x + padding &&
          rect1.y + padding < rect2.y + rect2.height - padding &&
          rect1.y + rect1.height - padding > rect2.y + padding
        );
      }

      gameOver() {
        this.gameState.gameOver = true;
        this.saveBestScore();
        this.elements.finalScore.textContent = `Pontuação Final: ${this.gameState.score}`;
        this.elements.gameOverOverlay.style.display = 'flex';
      }

      render() {
        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw background
        this.drawBackground();
        this.drawBackgroundElements();

        // Draw ground
        this.drawGround();

        // Draw game objects
        this.drawPudge();
        this.drawObstacles();
        this.drawParticles();

        // Draw effects
        this.drawScreenEffects();
      }

      drawBackground() {
        // Animated gradient background
        const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        const time = this.gameState.frame * 0.01;
        
        gradient.addColorStop(0, `hsl(${220 + Math.sin(time) * 10}, 30%, 15%)`);
        gradient.addColorStop(0.5, `hsl(${210 + Math.cos(time) * 10}, 25%, 10%)`);
        gradient.addColorStop(1, `hsl(${200 + Math.sin(time * 0.7) * 10}, 20%, 5%)`);
        
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      }

      drawBackgroundElements() {
        this.backgroundElements.forEach(element => {
          this.ctx.save();
          this.ctx.globalAlpha = element.opacity;
          this.ctx.fillStyle = '#ffffff';
          this.ctx.fillRect(element.x, element.y, element.size, element.size);
          this.ctx.restore();
        });
      }

      drawGround() {
        // Ground with texture
        const groundHeight = this.canvas.height - this.config.GROUND_Y;
        
        // Main ground
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.fillRect(0, this.config.GROUND_Y, this.canvas.width, groundHeight);
        
        // Ground surface
        this.ctx.fillStyle = '#333333';
        this.ctx.fillRect(0, this.config.GROUND_Y, this.canvas.width, 4);
        
        // Ground pattern
        this.ctx.strokeStyle = '#404040';
        this.ctx.lineWidth = 1;
        for (let x = 0; x < this.canvas.width; x += 40) {
          this.ctx.beginPath();
          this.ctx.moveTo(x, this.config.GROUND_Y + 4);
          this.ctx.lineTo(x, this.canvas.height);
          this.ctx.stroke();
        }
      }

      drawPudge() {
        const sprite = this.sprites.pudge;
        
        if (sprite && sprite.complete && sprite.naturalWidth > 0) {
          // Draw sprite with animation
          this.ctx.save();
          
          // Bounce animation when running
          const bounceOffset = this.pudge.grounded ? Math.sin(this.pudge.animFrame) * 2 : 0;
          
          this.ctx.drawImage(
            sprite, 
            this.pudge.x, 
            this.pudge.y + bounceOffset, 
            this.pudge.width, 
            this.pudge.height
          );
          
          this.ctx.restore();
        } else {
          // Enhanced fallback drawing
          this.drawPudgeFallback();
        }
      }

      drawPudgeFallback() {
        this.ctx.save();
        
        const bounceOffset = this.pudge.grounded ? Math.sin(this.pudge.animFrame) * 2 : 0;
        const x = this.pudge.x;
        const y = this.pudge.y + bounceOffset;
        
        // Body
        this.ctx.fillStyle = '#8B4513';
        this.ctx.fillRect(x + 15, y + 20, 60, 50);
        
        // Head
        this.ctx.fillStyle = '#D2B48C';
        this.ctx.fillRect(x + 20, y, 50, 40);
        
        // Eyes
        this.ctx.fillStyle = '#000000';
        this.ctx.fillRect(x + 25, y + 8, 8, 8);
        this.ctx.fillRect(x + 45, y + 8, 8, 8);
        
        // Mouth
        this.ctx.fillStyle = '#8B0000';
        this.ctx.fillRect(x + 30, y + 20, 20, 6);
        
        // Arms
        this.ctx.fillStyle = '#D2B48C';
        this.ctx.fillRect(x + 5, y + 25, 15, 30);
        this.ctx.fillRect(x + 70, y + 25, 15, 30);
        
        // Legs
        this.ctx.fillRect(x + 25, y + 65, 15, 25);
        this.ctx.fillRect(x + 50, y + 65, 15, 25);
        
        this.ctx.restore();
      }

      drawObstacles() {
        this.obstacles.forEach(obstacle => {
          const sprite = this.sprites[obstacle.type];
          
          if (sprite && sprite.complete && sprite.naturalWidth > 0) {
            // Animate obstacles with slight rotation
            this.ctx.save();
            const centerX = obstacle.x + obstacle.width / 2;
            const centerY = obstacle.y + obstacle.height / 2;
            
            this.ctx.translate(centerX, centerY);
            this.ctx.rotate(Math.sin(this.gameState.frame * 0.1 + obstacle.animOffset) * 0.1);
            this.ctx.translate(-centerX, -centerY);
            
            this.ctx.drawImage(sprite, obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            this.ctx.restore();
          } else {
            this.drawObstacleFallback(obstacle);
          }
        });
      }

      drawObstacleFallback(obstacle) {
        this.ctx.save();
        
        if (obstacle.type === 'hook') {
          // Chain
          this.ctx.strokeStyle = '#808080';
          this.ctx.lineWidth = 4;
          this.ctx.beginPath();
          this.ctx.moveTo(obstacle.x, obstacle.y);
          this.ctx.lineTo(obstacle.x + obstacle.width - 20, obstacle.y + obstacle.height / 2);
          this.ctx.stroke();
          
          // Hook
          this.ctx.fillStyle = '#e74c3c';
          this.ctx.fillRect(obstacle.x + obstacle.width - 20, obstacle.y + obstacle.height / 2 - 10, 20, 20);
          
          // Hook point
          this.ctx.fillStyle = '#c0392b';
          this.ctx.beginPath();
          this.ctx.moveTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height / 2);
          this.ctx.lineTo(obstacle.x + obstacle.width - 10, obstacle.y + obstacle.height / 2 - 8);
          this.ctx.lineTo(obstacle.x + obstacle.width - 10, obstacle.y + obstacle.height / 2 + 8);
          this.ctx.fill();
        } else {
          // Tree trunk
          this.ctx.fillStyle = '#8B4513';
          this.ctx.fillRect(
            obstacle.x + obstacle.width / 3, 
            obstacle.y + obstacle.height / 2, 
            obstacle.width / 3, 
            obstacle.height / 2
          );
          
          // Tree leaves
          this.ctx.fillStyle = '#228B22';
          this.ctx.beginPath();
          this.ctx.arc(
            obstacle.x + obstacle.width / 2, 
            obstacle.y + obstacle.height / 3, 
            obstacle.width / 2, 
            0, 
            Math.PI * 2
          );
          this.ctx.fill();
        }
        
        this.ctx.restore();
      }

      drawParticles() {
        this.particles.forEach(particle => {
          this.ctx.save();
          
          const alpha = particle.life / particle.maxLife;
          this.ctx.globalAlpha = alpha;
          
          this.ctx.fillStyle = particle.color;
          this.ctx.beginPath();
          this.ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
          this.ctx.fill();
          
          this.ctx.restore();
        });
      }

      drawScreenEffects() {
        if (this.gameState.gameOver) {
          // Screen shake effect
          this.ctx.save();
          this.ctx.globalAlpha = 0.1;
          this.ctx.fillStyle = '#ff0000';
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          this.ctx.restore();
        }
        
        // Speed lines for high speed
        if (this.gameState.speed > 7) {
          this.ctx.save();
          this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
          this.ctx.lineWidth = 2;
          
          for (let i = 0; i < 10; i++) {
            const y = (this.gameState.frame * (this.gameState.speed - 5) * 2 + i * 40) % this.canvas.height;
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(50, y);
            this.ctx.stroke();
          }
          
          this.ctx.restore();
        }
      }

      updateUI() {
        this.elements.currentScore.textContent = this.gameState.score;
        this.elements.currentLevel.textContent = this.gameState.level;
        this.elements.bestScore.textContent = this.getBestScore();
      }

      loadBestScore() {
        const saved = localStorage.getItem('pudgeRunnerBestScore');
        return saved ? parseInt(saved) : 0;
      }

      getBestScore() {
        return this.loadBestScore();
      }

      saveBestScore() {
        const currentBest = this.loadBestScore();
        if (this.gameState.score > currentBest) {
          localStorage.setItem('pudgeRunnerBestScore', this.gameState.score.toString());
        }
      }

      gameLoop() {
        if (!this.gameState.started) return;
        
        this.updateGame();
        this.render();

        if (!this.gameState.gameOver) {
          requestAnimationFrame(() => this.gameLoop());
        }
      }
    }

    // Initialize the game when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      new PudgeRunner();
    });

    // Start immediately if DOM is already loaded
    if (document.readyState === 'loading') {
      // DOM not ready yet
    } else {
      new PudgeRunner();
    }
  </script>
</body>
</html>
